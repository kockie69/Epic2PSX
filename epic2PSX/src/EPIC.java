import java.io.FileInputStream;
import java.io.IOException;
import java.nio.ByteBuffer;
import java.util.*;

import com.sun.jna.*;
import com.sun.jna.win32.*;

public class EPIC
{
	
	//events to EPIC
	public final static int DISPLAYBCD=12;				//9bytes	//B-display#,B-0 set,1 add,2 sub,3B digits0-5
	final static int DISPLAYINT=13;			//4bytes     //B-display#,W-integer value (0-FFFF)
	final static int PHDATA=16;				//6bytes     load pigeon hole	B-PH#,4B-data
	final static int PFDATA=17;				//load p flag
	final static int EXQP0=	0x20;	        //2bytes     execute qproc 0-255
	final static int EXQP1=	0x21;	        //2     execute qproc 256-511
	final static int EXQP2=	0x22;	        //2     execute qproc 512-767
	final static int EXQP3=	0x23;	        //2     execute qproc 768-1023

	//events from EPIC
	final static int DEVICE_BUTTON_ON=0x61;	//4 bytes ,61h,0,B-device#,B-button#
	final static int	DEVICE_BUTTON_OFF=0x60;
	final static int	EVENT_ON=0x90;	//2 data=event#	generated by ENQUE(<event#>,ON)	
	final static int	EVENT_OFF=0x80;	//2 data=event#	generated by ENQUE(<event#>,OFF)
	final static int	EVENT16_0=0xA0;	//4 bytes ,event#(0-0xFF),W-data
	final static int	EVENT16_1=0xA1;	//4 bytes ,event#(0x100-0x1FF),W-data
	final static int	EVENT16_2=0xA2;	//4 bytes ,event#(0x200-0x2FF),W-data
	final static int	EVENT16_3=0xA3;	//4 bytes ,event#(0x300-0x3FF),W-data
	final static int	EVENT16_4=0xA4;	//4 bytes ,event#(0x400-0x4FF),W-data
	final static int	EVENT16_5=0xA5;	//4 bytes ,event#(0x500-0x5FF),W-data
	final static int	EVENT16_6=0xA6;	//4 bytes ,event#(0x600-0x6FF),W-data
	final static int	EVENT16_7=0xA7;	//4 bytes ,event#(0x700-0x7FF),W-data
	final static int	EVENT16_8=0xA8;	//4 bytes ,event#(0X800-0x8FF),W-data
	final static int	EVENT16_9=0xA9;	//4 bytes ,event#(0x900-0x9FF),W-data
	final static int	EVENT16_A=0xAA;	//4 bytes ,event#(0xA00-0xAFF),W-data
	final static int	EVENT16_B=0xAB;	//4 bytes ,event#(0xB00-0xBFF),W-data
	final static int	EVENT16_C=0xAC;	//4 bytes ,event#(0xC00-0xCFF),W-data
	final static int	EVENT16_D=0xAD;	//4 bytes ,event#(0xD00-0xDFF),W-data
	final static int	EVENT16_E=0xAE;	//4 bytes ,event#(0xE00-0xEFF),W-data
	final static int	EVENT16_F=0xAF;	//4 bytes ,event#(0xF00-0xFFF),W-data

	final static int	EVENT32_0=0xB0;	//6 bytes ,event#(0-0xFF),W-data,W-data
	final static int	EVENT32_1=0xB1;	//6 bytes ,event#(0x100-0x1FF),W-data,W-data
	final static int	EVENT32_2=0xB2;	//6 bytes ,event#(0x200-0x2FF),W-data,W-data  
	final static int	EVENT32_3=0xB3;	//6 bytes ,event#(0x300-0x3FF),W-data,W-data
	final static int	EVENT32_4=0xB4;	//6 bytes ,event#(0x400-0x4FF),W-data,W-data
	final static int	EVENT32_5=0xB5;	//6 bytes ,event#(0x500-0x5FF),W-data,W-data
	final static int	EVENT32_6=0xB6;	//6 bytes ,event#(0x600-0x6FF),W-data,W-data
	final static int	EVENT32_7=0xB7;	//6 bytes ,event#(0x700-0x7FF),W-data,W-data
	final static int	EVENT32_8=0xB8;	//6 bytes ,event#(0X800-0x8FF),W-data,W-data
	final static int	EVENT32_9=0xB9;	//6 bytes ,event#(0x900-0x9FF),W-data,W-data
	final static int 	EVENT32_A=0xBA;	//6 bytes ,event#(0xA00-0xAFF),W-data,W-data
	final static int	EVENT32_B=0xBB;	//6 bytes ,event#(0xB00-0xBFF),W-data,W-data
	final static int	EVENT32_C=0xBC;	//6 bytes ,event#(0xC00-0xCFF),W-data,W-data
	final static int	EVENT32_D=0xBD;	//6 bytes ,event#(0xD00-0xDFF),W-data,W-data
	final static int	EVENT32_E=0xBE;	//6 bytes ,event#(0xE00-0xEFF),W-data,W-data
	final static int	EVENT32_F=0xBF;	//6 bytes ,event#(0xF00-0xFFF),W-data,W-data

	final static int EVENT_BREAKPOINT=0x08;
	final static int SOUND_ON=0x65;	//4 bytes ,65h,0,B-sound#,B-nothing
	
	final static int ERR_NOERROR=		0;
	final static int ERR_ERROR=			-1;		//unspecified error	(no events if returned from _GetEvent)
	final static int ERR_BADHANDLE=		-2;		//not a valid userHandle
	final static int ERR_NOHANDLE=		-3;		//no user userHandle available
	final static int ERR_NODEVICE=		-4;		//OS returned invalid userHandle (device may be unplugged )
	final static int ERR_MEMORY=			-5;		//not enough system memory to allocate buffers
	final static int ERR_BAD_DEVICENUM=	-6;		//Out of range device number
	final static int ERR_DEVICE_BUSY=		-7;		//requested device is busy
	final static int ERR_ID_ALREADY_REGISTERED= -8;
	final static int ERR_BUFFER_FULL=		-9;
	final static int ERR_LAST_ERROR=       10;              //value adjusted to always be last


	static int timer1ID = -1;
	static int epicDevice = -1;
	
	public static int handle = -1;
	static String str;
	static char[] scrapBuffer;
	static NetThread netThread; 
	public static int Autobr = 0;
	
	public static HashMap<String, StdCallFunctionMapper> options = new HashMap<String, StdCallFunctionMapper>();
	
	 public interface epicIOdll extends StdCallLibrary
	//public interface epicIOdll extends Library
	{
		
	  // epicIOdll INSTANCE = (epicIOdll)Native.loadLibrary("EPICIO",epicIOdll.class, options); 
	epicIOdll INSTANCE = (epicIOdll)Native.loadLibrary("C:/WINDOWS/SYSTEM32/EPICIO.DLL",epicIOdll.class,options);
		 //epicIOdll INSTANCE = (epicIOdll)Native.loadLibrary("C:/WINDOWS/SYSWOW64/EPICIO.DLL",epicIOdll.class,options);    		
			
	   public int __OpenEPIC(int EPICid,int destID);
	   
	   public int __CloseEPIC(int handle);
	   
	   public int __GetAnalogs(int userHandle,char[] analogs);
	   
	   public int __GetEvent(int handle,eventStruct eventPtr);
	   
	   public int __SendQP(int userHandle,int Qpnumb);
	   
	   public int __SendPH(int userHandle,int PHnumb,int data0,int data1,int data2,int data3);

	   
	   public int __SendPHint(int userHandle,int PHnumb,int data0,int data1);
	   
	   public int __GetCurrentButtonStates(int userHandle,int i,int j,
		          int k,byte[] switchDataPtr);

	   
	   public int __RequestDeviceData(int userHandle,int deviceNumber);
	   
	   public int __GetProjName(int userHandle, char[] infoBuffer);
	}

	public static void SendPH(int handle, int PH, short value1, short value2)
	{
		byte[] data1 = ByteBuffer.allocate(2).putShort(value1).array();
		byte[] data2 = ByteBuffer.allocate(2).putShort(value2).array();
		EPIC.epicIOdll.INSTANCE.__SendPH(handle,PH,data2[1],data2[0],data1[1],data1[0]);
		//System.out.println("Value1 for PH: " + value1);
		//System.out.println("Value2 for PH: " + value2);
		System.out.println("sendPHInt(" + handle + "," + PH + "," + data2[1] + "," + data2[0] + "," + data1[1] + "," + data1[0] + ")");
	}

	public static void SendQP(int handle, int QP)
	{
		EPIC.epicIOdll.INSTANCE.__SendQP(handle,QP);
		//System.out.println("Value1 for PH: " + value1);
		//System.out.println("Value2 for PH: " + value2);
		System.out.println("sendQP(" + handle + "," + QP + ")");
	}
	
	public static int OpenEPICDevice(int device,int destID)
	{
		checkEPIC task = new checkEPIC();
		
		if(epicDevice != -1) epicIOdll.INSTANCE.__CloseEPIC(handle);	//close current handle and get new handle
		epicDevice = device;
	    handle = epicIOdll.INSTANCE.__OpenEPIC(device,destID);

		if(handle  < 0)
		{ 
		   switch(handle)
		   {
		   	case ERR_ID_ALREADY_REGISTERED:
			   str = "Error: destID " + destID + " Already registered in EPICIO.DLL";
			   scrapBuffer = str.toCharArray();

			   System.out.println(scrapBuffer);
			   break;
		   	case ERR_NODEVICE:
				switch(epicDevice){
					case 0:
						System.out.println("EPICISA not found");
						break;
					default:
						str = "EPICUSB " + (epicDevice - 1) +" not found ";
						scrapBuffer = str.toCharArray();
						System.out.println(scrapBuffer);
				} 
				break;
			default:
				str = "OpenDevice returned(" + handle +")";
				scrapBuffer = str.toCharArray();
				System.out.println(scrapBuffer);
			}
		epicDevice = -1;
		return(-1);
		}

//		byte[] switchData = new byte[64];
//		EPIC.epicIOdll.INSTANCE.__GetCurrentButtonStates(EPIC.handle,1,0xff,0xff,switchData);

//		System.out.println("SwitchData: " + switchData[0]);

	//EPIC.epicIOdll.INSTANCE.__RequestDeviceData(EPIC.handle,10);
		char[] projectName = new char[64];
		//EPIC.epicIOdll.INSTANCE.__GetProjName(handle, projectName);

		System.out.println("ProjectName: " + projectName[0] + projectName[1] + projectName[2]);
		if (timer1ID == -1)  
			{
			Timer timer = new Timer();
			timer.scheduleAtFixedRate(task, 0, 50);
			}

		if(epicDevice == 0){
			str = "EPICISA destID=" + destID +",handle=" + handle;
			scrapBuffer = str.toCharArray();
			System.out.println(scrapBuffer);
		}
		else {
			str = "EPICUSB" + (epicDevice - 1) + "destID=" + destID +",handle=" + handle;
			scrapBuffer = str.toCharArray();
			System.out.println(scrapBuffer);
	 		}
		return(0);
	}
	
	synchronized static void sendToServer(String s) {
		if (netThread != null && s != null)
			netThread.send(s);
	}
			
	
	public static void main(String[] args) throws IOException {

		String fileName="src/EPIC2PSX.ini";
    	boolean succesfulStart = true;
    	Properties defaultProps = new Properties();
    	FileInputStream in = new FileInputStream(fileName);
    	defaultProps.load(in);
    	
		options.put(Library.OPTION_FUNCTION_MAPPER ,new StdCallFunctionMapper());	
		
		mappings.readAll();
		if (defaultProps.getProperty("epic").equals("true")) {
		// Epic is connected so open a device
			System.out.println("Configuration says Epic is connected");
			if (OpenEPICDevice(1,20)==-1) {
				succesfulStart = false;
			}
		}
		if (succesfulStart) {
			String host = defaultProps.getProperty("host");
			int port = Integer.parseInt(defaultProps.getProperty("port"));
		
			netThread = new NetThread(host, port);
			netThread.start();
//				} else {
//				if (netThread != null)
//						netThread.finalJobs();	
	    }
	    //epicIOdll.INSTANCE.__CloseEPIC(1);
	}
}

